<script>
    (function(){
        let ctx;

        function createCtx(){
            if (!ctx || ctx.state === 'closed') {
                ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            return ctx;
        }

        function playJingle(){
            const audio = createCtx();
            const t0 = audio.currentTime + 0.04;

            // Master
            const master = audio.createGain();
            master.gain.value = 0.14;
            master.connect(audio.destination);

            // Sehr dezentes Stereo-Delay (weniger Überlagerung)
            const wetBus = audio.createGain(); wetBus.gain.value = 0.24;
            const delayL = audio.createDelay(1); delayL.delayTime.value = 0.19;
            const fbL = audio.createGain(); fbL.gain.value = 0.06;
            const panL = audio.createStereoPanner(); panL.pan.value = -0.18;

            const delayR = audio.createDelay(1); delayR.delayTime.value = 0.25;
            const fbR = audio.createGain(); fbR.gain.value = 0.05;
            const panR = audio.createStereoPanner(); panR.pan.value = 0.18;

            wetBus.connect(delayL); wetBus.connect(delayR);
            delayL.connect(fbL); fbL.connect(delayL);
            delayR.connect(fbR); fbR.connect(delayR);
            delayL.connect(panL); panL.connect(master);
            delayR.connect(panR); panR.connect(master);

            function freq(semitonesFromA4){
                return 440 * Math.pow(2, semitonesFromA4 / 12);
            }

            // Sanfte Kalimba-Voice, kurze Tails
            function kalimba(f, when, {
                dur = 0.65,
                peak = 0.78,
                send = 0.28,
                pan = 0.0,
                color = 0.9,     // 0.7–1.0: dunkler–heller
                tailPad = 0.12   // zusätzliche Zeit bis Stop (kurz halten)
            } = {}){
                const g = audio.createGain(); g.gain.value = 0;
                const p = audio.createStereoPanner(); p.pan.value = pan;

                const lp = audio.createBiquadFilter();
                lp.type = 'lowpass';
                lp.frequency.value = 2100 * color;
                lp.Q.value = 0.7;

                // Dezent: minimale Filterbewegung (wenig Schimmer)
                const lfo = audio.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 4.6;
                const lfoGain = audio.createGain(); lfoGain.gain.value = 60 * color;
                lfo.connect(lfoGain); lfoGain.connect(lp.frequency);
                lfo.start(when); lfo.stop(when + dur + tailPad);

                const o1 = audio.createOscillator(); o1.type = 'sine';     o1.frequency.value = f;
                const o2 = audio.createOscillator(); o2.type = 'triangle'; o2.frequency.value = f * 2.12;
                const o3 = audio.createOscillator(); o3.type = 'sine';     o3.frequency.value = f * 3.3;

                const o1g = audio.createGain(); o1g.gain.value = 1.0;
                const o2g = audio.createGain(); o2g.gain.value = 0.20 * color;
                const o3g = audio.createGain(); o3g.gain.value = 0.12 * color;

                const sendGain = audio.createGain(); sendGain.gain.value = send;

                o1.connect(o1g); o2.connect(o2g); o3.connect(o3g);
                o1g.connect(lp); o2g.connect(lp); o3g.connect(lp);
                lp.connect(g); lp.connect(sendGain);
                sendGain.connect(wetBus);
                g.connect(p); p.connect(master);

                // Sehr kleiner „Klick“
                const noiseBuf = audio.createBuffer(1, audio.sampleRate * 0.012, audio.sampleRate);
                const nd = noiseBuf.getChannelData(0);
                for (let i = 0; i < nd.length; i++) nd[i] = (Math.random() * 2 - 1);
                const nsrc = audio.createBufferSource(); nsrc.buffer = noiseBuf;
                const nhp = audio.createBiquadFilter(); nhp.type = 'highpass'; nhp.frequency.value = 950;
                const nbp = audio.createBiquadFilter(); nbp.type = 'bandpass'; nbp.frequency.value = 1700; nbp.Q.value = 2.2;
                const ng = audio.createGain(); ng.gain.value = 0;
                nsrc.connect(nhp); nhp.connect(nbp); nbp.connect(ng); ng.connect(g);

                // Envelope: schneller Attack, kurzer, runder Tail
                const a = 0.008;
                g.gain.setValueAtTime(0, when);
                g.gain.linearRampToValueAtTime(peak, when + a);
                g.gain.setTargetAtTime(peak * 0.55, when + a + 0.09, 0.14); // runder Bauch, zügiges Abklingen
                g.gain.setTargetAtTime(0.0001, when + a + (dur * 0.70), 0.22);

                ng.gain.setValueAtTime(0, when);
                ng.gain.linearRampToValueAtTime(0.12, when + 0.004);
                ng.gain.exponentialRampToValueAtTime(0.0001, when + 0.05);

                lp.frequency.setValueAtTime(2100 * color, when);
                lp.frequency.exponentialRampToValueAtTime(1100 * color, when + dur);

                const stopAt = when + a + dur + tailPad;
                o1.start(when); o2.start(when); o3.start(when); nsrc.start(when);
                o1.stop(stopAt); o2.stop(stopAt); o3.stop(stopAt); nsrc.stop(when + 0.06);
            }

            // Sehr dezente Drops (noch kürzer)
            function droplet(startF, endF, when, dur = 0.22, send = 0.22){
                const osc = audio.createOscillator(); osc.type = 'sine';
                const gain = audio.createGain(); gain.gain.value = 0;
                const bp = audio.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 880; bp.Q.value = 1.3;
                const sendGain = audio.createGain(); sendGain.gain.value = send;

                osc.frequency.setValueAtTime(startF, when);
                osc.frequency.exponentialRampToValueAtTime(endF, when + dur);

                osc.connect(bp); bp.connect(gain); bp.connect(sendGain);
                sendGain.connect(wetBus); gain.connect(master);

                const a = 0.003;
                gain.gain.setValueAtTime(0, when);
                gain.gain.linearRampToValueAtTime(0.30, when + a);
                gain.gain.exponentialRampToValueAtTime(0.0001, when + dur);

                osc.start(when);
                osc.stop(when + dur + 0.10);
            }

            // Melodie mit minimaler Überlagerung: klare Pausen und kurze Tails
            // Phrase A (präsenter, aber kurz)
            kalimba(freq(5),  t0 + 0.00, { dur: 0.64, peak: 0.78, send: 0.26, pan: -0.05, color: 0.95, tailPad: 0.10 }); // D5
            droplet(1400,     700, t0 + 0.16, 0.20, 0.20);
            kalimba(freq(7),  t0 + 0.30, { dur: 0.64, peak: 0.78, send: 0.26, pan:  0.05, color: 0.95, tailPad: 0.10 }); // E5
            kalimba(freq(9),  t0 + 0.56, { dur: 0.60, peak: 0.76, send: 0.24, pan: -0.04, color: 0.92, tailPad: 0.10 }); // F#5

            // kleine Pause zwischen den Phrasen (verhindert Übersprechen)
            const t1 = t0 + 0.90;

            // Phrase B (sanfter, dunkler, längerer Ausklang, aber weniger stark)
            kalimba(freq(7),  t1 + 0.00, { dur: 0.72, peak: 0.66, send: 0.28, pan:  0.03, color: 0.85, tailPad: 0.14 }); // E5
            droplet(1150,     600, t1 + 0.18, 0.20, 0.18);
            kalimba(freq(12), t1 + 0.32, { dur: 0.76, peak: 0.64, send: 0.30, pan: -0.02, color: 0.82, tailPad: 0.16 }); // G5
            kalimba(freq(14), t1 + 0.60, { dur: 0.82, peak: 0.62, send: 0.30, pan:  0.02, color: 0.80, tailPad: 0.18 }); // A5 (sanftes Auslaufen)

            // Hinweis: Bei Bedarf kannst du die Pause (t1) vergrößern oder send/wet weiter reduzieren.
        }

        async function startAfterGesture(){
            const handler = async () => {
                try {
                    ctx = createCtx();
                    if (ctx.state !== 'running') await ctx.resume();
                } catch (e) {}
                playJingle();
                window.removeEventListener('pointerdown', handler);
                window.removeEventListener('touchstart', handler);
                window.removeEventListener('keydown', handler);
            };
            window.addEventListener('pointerdown', handler, { once: true });
            window.addEventListener('touchstart', handler, { once: true });
            window.addEventListener('keydown', handler, { once: true });
        }

        window.playBettaJingle = async function(){
            ctx = createCtx();
            if (ctx.state !== 'running') await ctx.resume();
            playJingle();
        };

        if (window.location.pathname === '/' || window.location.pathname === '/index.html') {
            startAfterGesture();
        }
    })();
</script>
